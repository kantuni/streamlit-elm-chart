{"version":3,"sources":["utils.ts","index.ts"],"names":["getColor","index","beautifulColors","length","random","app","window","Elm","Main","init","node","document","getElementById","Streamlit","events","addEventListener","RENDER_EVENT","event","args","detail","transformedChartData","data","groupedByRegion","groupBy","Object","entries","map","region","entry","omit","color","transform","JSON","parse","ports","fromJS","send","setComponentReady","setFrameHeight"],"mappings":"iKAiBA,SAASA,EAASC,GAChB,IAAMC,EAAkB,CACtB,CAAC,IAAK,GAAI,IACV,CAAC,IAAK,IAAK,IACX,CAAC,IAAK,IAAK,IACX,CAAC,GAAI,IAAK,IACV,CAAC,EAAG,IAAK,KACT,CAAC,EAAG,IAAK,KACT,CAAC,GAAI,IAAK,KACV,CAAC,IAAK,GAAI,MAEZ,OAAOD,EAAQC,EAAgBC,OAC3BD,EAAgBD,GAChB,CAACG,iBAAO,EAAG,KAAMA,iBAAO,EAAG,KAAMA,iBAAO,EAAG,MCrBjD,IAAMC,EAAMC,OAAOC,IAAIC,KAAKC,KAAK,CAC/BC,KAAMC,SAASC,eAAe,UAsBhCC,IAAUC,OAAOC,iBAAiBF,IAAUG,cAd5C,SAAkBC,GAAoB,IAE5BC,EAAUD,EAAkCE,OAA5CD,KAKFE,EDjBD,SAAmBC,GACxB,IAAMC,EAAkBC,kBAAQF,EAAM,UACtC,OAAOG,OAAOC,QAAQH,GAAiBI,KAAI,WAAiBzB,GAAjB,6BAA4B,CACrE0B,OADyC,KAEzCN,KAFyC,KAE9BK,KAAI,SAACE,GAAD,OAAWC,eAAKD,EAAO,aACtCE,MAAO9B,EAASC,OCYW8B,CADFC,KAAKC,MAAMf,EAAKG,OAI3ChB,EAAI6B,MAAMC,OAAOC,KAAKhB,MAQxBP,IAAUwB,oBAIVxB,IAAUyB,kB","file":"static/js/main.c35b5ffa.chunk.js","sourcesContent":["import { groupBy, omit, random } from \"lodash\"\n\nexport interface Point {\n  Region: string\n  x: number\n  y: number\n}\n\nexport function transform(data: Point[]) {\n  const groupedByRegion = groupBy(data, \"Region\")\n  return Object.entries(groupedByRegion).map(([region, data], index) => ({\n    region,\n    data: data.map((entry) => omit(entry, \"Region\")),\n    color: getColor(index),\n  }))\n}\n\nfunction getColor(index: number) {\n  const beautifulColors = [\n    [255, 75, 75],\n    [255, 164, 33],\n    [255, 227, 18],\n    [33, 195, 84],\n    [0, 212, 177],\n    [0, 192, 242],\n    [28, 131, 225],\n    [128, 61, 245],\n  ]\n  return index < beautifulColors.length\n    ? beautifulColors[index]\n    : [random(0, 255), random(0, 255), random(0, 255)]\n}\n","import { RenderData, Streamlit } from \"streamlit-component-lib\"\nimport { Point, transform } from \"./utils\"\n\ndeclare global {\n  interface Window {\n    Elm: any\n  }\n}\n\nconst app = window.Elm.Main.init({\n  node: document.getElementById(\"root\"),\n})\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData args from the event.\n  const { args } = (event as CustomEvent<RenderData>).detail\n\n  // RenderData args is the JSON dictionary of arguments\n  // sent from the Python script.\n  const chartData: Point[] = JSON.parse(args.data)\n  const transformedChartData = transform(chartData)\n\n  // Notify Elm that the chart data has changed.\n  app.ports.fromJS.send(transformedChartData)\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"],"sourceRoot":""}